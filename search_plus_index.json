{"./":{"url":"./","title":"前言","keywords":"","body":"简介 开发中的一些z总结 Copyright © eric_dayang 2017 all right reserved，powered by Gitbook编辑时间： 2020-05-29 17:03:36 "},"git/git_to_git.html":{"url":"git/git_to_git.html","title":"如何把Git 从一个Git 仓库切换到另一个Git仓库","keywords":"","body":"如何将一个Git仓库迁移到另外的Git仓库 参考 很有可能我们有这样一个需求，我们的工程使用的是A服务器的仓库来管理，突然有一天领导告诉你，让你把的工程迁移到B服务器上去，那么问题来了 1、我们有有N多个分支. 2、我们有N多个tag。 3、我们有N多次的提交。 在这种情况下我们如何来迁移了。如何把这些内容完全迁移到我们另外的一个GI 服务器上去呢？ 那么按照下面的方法就能解决此需求。 一、第一步 把服务器上得所有分支和tag先拉取到本地 拉去分支到本地 git branch -a 查看所有的分支 git checkout branch-name 检出所有分支到本地 拉去所有的TAG 到本地 git fetch --tags 二、 更换远端资源连接到新的连接 git remote rm origin 清除本地和远端的资源连接 git remote add origin 建立新的连接 三、把本地的资源推到新仓库 git push origin --all git push --tags 结束。 You now have a full copy from your ORI repo. ​ Copyright © eric_dayang 2017 all right reserved，powered by Gitbook编辑时间： 2019-09-08 13:58:45 "},"cocoaPods/cocoaPods.html":{"url":"cocoaPods/cocoaPods.html","title":"私有仓库的创建和使用","keywords":"","body":"cocoaPods 私有仓库的创建和使用 一、创建远程的POD 仓库 直接在git上创建一个空的pod仓库即可， 执行 pod repo add #仓库名字# 仓库地址 自动会将远程私有仓库clone到 /Users/用户名/.cocoapods/repos 目录下。 自此 远程仓库已经准备好了。 二、创建本地的组件 使用命令 pod lib create [pod name] 会自动创建一个本地的库，我们可以在这里开发我们的组件库。 这里最主要的是NAME.podspec 这个文件的配置 类似如下 # # Be sure to run `pod lib lint AUExtension.podspec' to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html # Pod::Spec.new do |s| s.name = 'AUExtension' s.version = '0.1.9' # 版本号，这个版本号一定要和tag号一致，需要先打tag, s.summary = 'A short description of AUExtension.' # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don't worry about the indent, CocoaPods strips it! s.description = 'MIT', :file => 'LICENSE' } s.author = { 'ericdream' => '595814260@qq.com' } s.source = { :git => '你的代码仓库地址', :tag => s.version.to_s } # s.social_media_url = 'https://twitter.com/' s.ios.deployment_target = '8.0' s.source_files = 'AUExtension/Classes/AUExtension.h' s.subspec 'MiscExtend' do |ss| ss.source_files = 'AUExtension/Classes/MiscExtend/**/*.{h,m}' end s.subspec 'UIExtend' do |ss| ss.source_files = 'AUExtension/Classes/UIExtend/**/*.{h,m}' ss.dependency 'AUExtension/MiscExtend' mrcFiles = 'AUExtension/Classes/UIExtend/**/UIViewController+ExchageDeallocFunction.{h,m}' ss.exclude_files = mrcFiles ss.subspec 'MRC' do |sp| sp.source_files = mrcFiles sp.requires_arc = false end end # s.resource_bundles = { # 'AUExtension' => ['AUExtension/Assets/*.png'] # } # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~> 2.3' end version: 组件的版本号，必须和tag 号保持一致 source_files :资源的路径， exclude_fies : 忽略的资源文件，不包含 requires_arc : 是否开启arc 默认开启arc public_header_files :头文件 frameworks: 需要的frameworks libraries :所有的libraries，注意：需要去掉前缀 lib,如：s.libraries='z.1.2.5' (依赖库：libz.1.2.5) dependency: 需要的依赖 特别注意，cocoapod中没有文件目录的概念，只有子组件的概念，如果没有子组件，所有的文件都在同一级目录下，要'分目录'就要建立子组件。每一个子组件就是一个目录。子组件之间相互依赖调用的时候需要依赖被调用的组件。 配置文件修改完成之后，可以提交代码到远端，并打一个tag,tag和 配置文件中的s.version 保持一致。 三、验证并推到把cocoaPods 配置文件推送到远端仓库 配置文件写完成之后我们需要验证配置文件的正确性。那么如何验证呢。 通过命令：pod lib lint name.podspec --use-libraries --allow-warnings --verbose 后边参数可以去掉，建议加上，第一个参数不加可能不会通过验证，不忽略警公告也不会验证通过， 验证通过之后我们就可以把配置文件推送的pod远端仓库： pod repo push 仓库名 配置文件.podspec --sources='自己仓库地址,https://github.com/CocoaPods/Specs.git' --use-libraries --allow-warnings --verbose 如果你的组件不依赖私有组件可以去电自己的pod私有仓库地址。 执行这条命令之后，系统会自动的在 /Users/用户名/.cocoapods/repos 目录下 创建一个和版本号同名的目录，并把配置文件copy进来，然后在另外的一个目录下创建工作空间，并编译你的组件，编译通过之后才真正的把配置文件提交到pod仓库。 自此pod 库完成制作。 四、使用 要使用我们自己自作的私有仓库首先你需要在 profile 文件中添加上你的仓库源地址： 如：source 'http://gitlab........respos.git' 然后再添加仓库： pod '组件名' pod 版本共控制 pod '组件', '1.0' # 指定版本 '> 0.1' 0.1 以上 '>= 0.1' 大于等于 0.1 ' ' '~> 0.1.2' # 0.1 以上，0.2 一下 '~>0.1' # 0.1以上 1.0 一下 最后只需要执行命令： pod install 完成。 Copyright © eric_dayang 2017 all right reserved，powered by Gitbook编辑时间： 2019-09-08 15:30:30 "},"flutter/flutterInstall.html":{"url":"flutter/flutterInstall.html","title":"Flutter快速集成","keywords":"","body":"如何在iOS中快速集成Flutter 摘要： 如何快速集成 Flutter 到 原生项目。 集成之后如何使用flutter。 一、如何快速集成 集成的方式一般有两种：手动导入和pods 自动导入。 手动导入就不用多说了直接把相应的framework 拖入项目即可，这种方式是比较笨重的（但也有大神自己写脚本来实现），我们来说说如何使用pods 快速集成吧。 1、第一步：创建配置文件 我们需要创建三个配置文件： Debug.xcconfig Release.xcconfig Flutter.xcconfig Debug.xcconfig #include \"Flutter.xcconfig\" #include \"Pods/Target Support Files/Pods-你自己的工程名字/Pods-你自己的工程名字.debug.xcconfig\" Release.xcconfig #include \"Flutter.xcconfig\" #include \"Pods/Target Support Files/Pods-你自己的工程名字/Pods-你自己的工程名字.debug.xcconfig\" Flutter.xcconfig #include \"../my_flutter/.ios/Flutter/Generated.xcconfig\" // 需要改成你自己的目录 ENABLE_BITCODE=NO // 关闭bitecdoe 2、添加配置文件到工程中 PROJECT-->info--->Configurations 配置成之前我们自己创建文件.xcconfig( 有iOS开发经验的应该都能看得懂) 3、添加编译flutter的脚本 Target->Build Phases->Run Script 中添加flutter包中工具中的一个工具脚本·xcode_backend.sh。 这个脚本干了那些事呢，主要有一下几点： 导入Flutter引擎的对应模式版本。 编译Dart代码为App.framework。 编译flutter_assets，并内嵌到App.framework。 复制资源，并签名 脚本如下 \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build FLUTTER_ROOT 这个变量是在Generated.xcconfig 配置文件中配的，会自动生成，指向的是flutter SDK所在的更目录。 4、配置PODS profile 文件 先上代码： flutter_application_path = '../' load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb') use_frameworks! target 'Runner' do install_flutter_engine_pod install_flutter_plugin_pods flutter_application_path end 下面我们来解释下： 其中非常关键的是podhelper 这个文件，在.ios/Flutte/ 目录下。 这个文件我不做具体解释，有兴趣的可以研究下， 首先是导入这个文件，因为我们需要使用到里边的一些方法。 install_flutter_engine_pod 方法： 其作用很简单：pod 'Flutter, 就是Flutter引擎当做一个组件pod 到我们的工程中去。 install_flutter_plugin_pods 方法： 其作用就是把Flutter插件导入到我们项目中去， 在.ios 目录下所有的Flutte 插件将会生成相对应的pod 组件，在对应的.symlinks 目录下,通过pod 的方式导入到我们的项目中。 5、pod install 完成集成 最后只需要使用命令：pod install 就可以完成集成工作。 二、如何使用Flutter 这里做一个简单的示范例子: 通过 FlutterViewController 来完成从原生到flutter 的跳转。 FlutterViewController *vc = [[FlutterViewController alloc] init]; [vc setInitialRoute:@\"FirstView\"]; [self.navigationController pushViewController:vc animated:YES]; 其中 FirstView 是一个标识，用于在flutter 中判断具体跳转到哪个页面Widget void main() { if(window.defaultRouteName ==\"FirstView\"){ return runApp(FirstView()); }else if(window.defaultRouteName == \"SecondView\"){ return runApp(SecondView()); }else{ return runApp(FirstView()); } } 这样就完成了从原生到flutter 的一个跳转过程。 但是如果我们在flutter 使用了插件的时候，仅仅这样是不够的。 如果使用了插件，在iOS中我们还需要注册这些插件: #import #import @interface AppDelegate : FlutterAppDelegate @property (nonatomic,strong)FlutterEngine *flutterEngine; @end #import \"AppDelegate.h\" #import @interface AppDelegate () @end @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"io.flutter\" project:nil]; [self.flutterEngine runWithEntrypoint:nil]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } FlutterEngine *flutterEngine = ((AppDelegate *)[UIApplication sharedApplication].delegate).flutterEngine; FlutterViewController *vc = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; [vc setInitialRoute:@\"FirstView\"]; [self.navigationController pushViewController:vc animated:YES]; Copyright © eric_dayang 2017 all right reserved，powered by Gitbook编辑时间： 2020-05-29 15:03:50 "}}